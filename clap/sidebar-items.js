initSidebarItems({"enum":[["AppSettings","Application level settings, which affect how `App` operates"],["ClapErrorType","Command line argument parser error types"],["Format","Defines styles for different types of error messages. Defaults to Error=Red, Warning=Yellow, and Good=Green"]],"macro":[["arg_enum!","Convenience macro to generate more complete enums with variants to be used as a type when parsing arguments. This enum also provides a `variants()` function which can be used to retrieve a `Vec<&'static str>` of the variant names.**NOTE:** Case insensitivity is supported for ASCII characters**NOTE:** This macro automatically implements std::str::FromStr and std::fmt::DisplayThese enums support pub (or not) and use of the #[derive()] traitsExamples"],["clap_app!","App, Arg, SubCommand and Group builder macro (Usage-string like input)"],["crate_version!","Allows you pull the version for an from your Cargo.toml as MAJOR.MINOR.PATCH_PKGVERSION_PREExamples"],["simple_enum!","Convenience macro generated a simple enum with variants to be used as a type when parsing arguments. This enum also provides a `variants()` function which can be used to retrieve a `Vec<&'static str>` of the variant names.**NOTE:** This macro automatically implements std::str::FromStr and std::fmt::DisplayExamples"],["value_t!","Convenience macro getting a typed value `T` where `T` implements `std::str::FromStr` This macro returns a `Result<T,String>` which allows you as the developer to decide what you'd like to do on a failed parse. There are two types of errors, parse failures and those where the argument wasn't present (such as a non-required argument).You can use it to get a single value, or a `Vec<T>` with the `values_of()`**NOTE:** Be cautious, as since this a macro invocation it's not exactly like standard syntax.Examples single valueExamples multiple values"],["value_t_or_exit!","Convenience macro getting a typed value `T` where `T` implements `std::str::FromStr` This macro returns a `T` or `Vec<T>` or exits with a usage string upon failure. This removes some of the boiler plate to handle failures from value_t! above.You can use it to get a single value `T`, or a `Vec<T>` with the `values_of()`**NOTE:** This should only be used on required arguments, as it can be confusing to the user why they are getting error messages when it appears they're entering all required arguments.**NOTE:** Be cautious, as since this a macro invocation it's not exactly like standard syntax.Examples single valueExamples multiple values"]],"struct":[["App","Used to create a representation of a command line program and all possible command line arguments.Application settings are set using the \"builder pattern\" with `.get_matches()` being the terminal method that starts the runtime-parsing process and returns information about the user supplied arguments (or lack there of).There aren't any mandatory \"options\" that one must set. The \"options\" may also appear in any order (so long as `.get_matches()` is the last method called).Examples"],["Arg","The abstract representation of a command line argument used by the consumer of the library. Used to set all the options and relationships that define a valid argument for the program.This struct is used by the library consumer and describes the command line arguments for their program. Then evaluates the settings the consumer provided and determines the concret argument type to use when parsing.There are two methods for constructing `Arg`s, using the builder pattern and setting options manually, or using a usage string which is far less verbose. You can also use a combination of the two methods to achieve the best of both worlds.**NOTE*: Fields of this struct are **not** meant to be used directly unless absolutely required. 99.9% of the tasks can be performed without accessing these fields directly.Examples"],["ArgGroup","`ArgGroup`s are a family of related arguments and way for you to say, \"Any of these arguments\". By placing arguments in a logical group, you can make easier requirement and exclusion rules instead of having to list each individually, or when you want a rule to apply \"any but not all\" arguments.For instance, you can make an entire ArgGroup required, this means that one (and *only* one) argument. from that group must be present. Using more than one argument from an ArgGroup causes a failure (graceful exit).You can also do things such as name an ArgGroup as a confliction or requirement, meaning any of the arguments that belong to that group will cause a failure if present, or must present respectively.Perhaps the most common use of `ArgGroup`s is to require one and *only* one argument to be present out of a given set. Imagine that you had multiple arguments, and you want one of them to be required, but making all of them required isn't feasible because perhaps they conflict with each other. For example, lets say that you were building an application where one could set a given version number by supplying a string with an option argument, i.e. `--set-ver v1.2.3`, you also wanted to support automatically using a previous version number and simply incrementing one of the three numbers. So you create three flags `--major`, `--minor`, and `--patch`. All of these arguments shouldn't be used at one time but you want to specify that *at least one* of them is used. For this, you can create a group.Examples"],["ArgMatches","Used to get information about the arguments that where supplied to the program at runtime by the user. To get a new instance of this struct you use `.get_matches()` of the `App` struct.Examples"],["ClapError","Command line argument parser error"],["SubCommand","The abstract representation of a command line subcommand used by the consumer of the library.This struct is used by the library consumer and describes all the valid options of the subcommand for their program. SubCommands are treated like \"sub apps\" and contain all the same possibilities (such as their own arguments and subcommands).Examples"]]});