initSidebarItems({"struct":[["DirEntry","A directory entry.This is the type of value that is yielded from the iterators defined in this crate.Differences with `std::fs::DirEntry`This type mostly mirrors the type by the same name in `std::fs`. There are some differences however:All recursive directory iterators must inspect the entry's type. Therefore, the value is stored and its access is guaranteed to be cheap and successful. `path` and `file_name` return borrowed variants. If `follow_links` was enabled on the originating iterator, then all operations except for `path` operate on the link target. Otherwise, all operations operate on the symbolic link."],["Error","An error produced by recursively walking a directory.This error type is a light wrapper around `std::io::Error`. In particular, it adds the following information:The depth at which the error occurred in the file tree, relative to the root. The path, if any, associated with the IO error. An indication that a loop occurred when following symbolic links. In this case, there is no underlying IO error. To maintain good ergnomics, this type has a `impl From<Error> for std::io::Error` defined so that you may use an `io::Result` with methods in this crate if you don't care about accessing the underlying error data in a structured form."],["Iter","An iterator for recursively descending into a directory.A value with this type must be constructed with the `WalkDir` type, which uses a builder pattern to set options such as min/max depth, max open file descriptors and whether the iterator should follow symbolic links.The order of elements yielded by this iterator is unspecified."],["IterFilterEntry","A recursive directory iterator that skips entries.Directories that fail the predicate `P` are skipped. Namely, they are never yielded and never descended into.Entries that are skipped with the `min_depth` and `max_depth` options are not passed through this filter.If opening a handle to a directory resulted in an error, then it is yielded and no corresponding call to the predicate is made.Type parameter `I` refers to the underlying iterator and `P` refers to the predicate, which is usually `FnMut(&DirEntry) -> bool`."],["WalkDir","A builder to create an iterator for recursively walking a directory.Results are returned in depth first fashion, with directories yielded before their contents. The order is unspecified. Directory entries `.` and `..` are always omitted.If an error occurs at any point during iteration, then it is returned in place of its corresponding directory entry and iteration continues as normal. If an error occurs while opening a directory for reading, it is skipped. Iteration may be stopped at any time. When the iterator is destroyed, all resources associated with it are freed.UsageThis type implements `IntoIterator` so that it may be used as the subject of a `for` loop. You may need to call `into_iter` explicitly if you want to use iterator adapters such as `filter_entry`.Idiomatic use of this type should use method chaining to set desired options. For example, this only shows entries with a depth of `1`, `2` or `3` (relative to `foo`):Note that the iterator by default includes the top-most directory. Since this is the only directory yielded with depth `0`, it is easy to ignore it with the `min_depth` setting:This will only return descendents of the `foo` directory and not `foo` itself.LoopsThis iterator (like most/all recursive directory iterators) assumes that no loops can be made with *hard* links on your file system. In particular, this would require creating a hard link to a directory such that it creates a loop. On most platforms, this operation is illegal.Note that when following symbolic/soft links, loops are detected and an error is reported."]],"trait":[["WalkDirIterator","A trait for recursive directory iterators."]],"type":[["Result","A result type for walkdir operations.Note that this result type embeds the error type in this crate. This is only useful if you care about the additional information provided by the error (such as the path associated with the error or whether a loop was dectected). If you want things to Just Work, then you can use `io::Result` instead since the error type in this package will automatically convert to an `io::Result` when using the `try!` macro."]]});